# -*- coding: utf-8 -*-
"""Sales transactions cleaning.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1MknZtd1fYJekejSOZXwl2GwUXmLoVOEm
"""

# importy + import csv

import pandas as pd
import numpy as np

df = pd.read_csv('sales_transaction.csv')
df.info()

#  PoÄet Å™Ã¡dkÅ¯: 536 350 TransactionNo, ProductNo, ProductName, Date, Country jsou textovÃ© (object)
#  TransactionNo a ProductNo bychom pÅ™evÃ©st na int, jsou ÄistÄ› ÄÃ­selnÃ©.
#  CustomerNo mÃ¡ 536 295 hodnot z 536 350 â€“ chybÃ­ nÃ¡m 55 hodnot (pravdÄ›podobnÄ› anonymnÃ­ zÃ¡kaznÃ­ci).
#  Datum (Date) je stÃ¡le object â€“  pÅ™evÃ©st na datetime.
#  Price je float64 (OK), Quantity je int64 (OK).
#  Quantity je u nÄ›kterÃ½ch poloÅ¾ek v zÃ¡pornÃ½ch hodnotÃ¡ch

df.head()

# ZmÄ›na formÃ¡tu Äasu na evropskÃ½
df["Date"] = pd.to_datetime(df["Date"], format="%m/%d/%Y").dt.strftime("%d/%m/%Y")

# ZmÄ›na ÄÃ­sla zÃ¡kaznÃ­ka na celÃ© ÄÃ­slo
df["CustomerNo"] = df["CustomerNo"].astype("Int64")

df["CustomerNo"].dtype  # MÄ›lo by vrÃ¡tit Int64
df["CustomerNo"].head(10)  # Pro kontrolu prvnÃ­ch 10 hodnot

# TransactionNo a ProductNo - pÅ™evod z object na int
df["TransactionNo"] = pd.to_numeric(df["TransactionNo"], errors='coerce').astype('Int64') # Handle non-numeric values by converting to NaN, then to Int64
df["ProductNo"] = pd.to_numeric(df["ProductNo"], errors='coerce').astype('Int64') # Apply similar logic to ProductNo column

df["TransactionNo"].dtype  # MÄ›lo by vrÃ¡tit Int64
df["TransactionNo"].head(10)  # Pro kontrolu prvnÃ­ch 10 hodnot

df["ProductNo"].dtype  # MÄ›lo by vrÃ¡tit Int64
df["ProductNo"].head(10)  # Pro kontrolu prvnÃ­ch 10 hodnot

#  Kontrola formÃ¡tu
df.info()

# kontrola nulovÃ½ch hodnot
df.isna().sum()

#  Co s nulovÃ½mi hodnotami?
#  TransactionNo mÃ¡ 8 585 chybÄ›jÃ­cÃ­ch hodnot â†’ chybÄ›jÃ­cÃ­ ÄÃ­slo transakce
#  Quantity mÃ¡ 8585 zÃ¡pornÃ½ch hodnot - vratky a reklamace?
#  ProductNo mÃ¡ 50 921 chybÄ›jÃ­cÃ­ch hodnot â†’ chybÄ›jÃ­cÃ­ produktovÃ© ÄÃ­slo
#  CustomerNo mÃ¡ 55 chybÄ›jÃ­cÃ­ch hodnot â†’ chybÄ›jÃ­cÃ­ ID zÃ¡kaznÃ­ka

# Seznam poloÅ¾ek s chybÄ›jÃ­cÃ­m produktovÃ½m ÄÃ­slem
df_missing_product = df[df["ProductNo"].isna()]
df_missing_product.head()

# Opakuje se produkt s chybÄ›jÃ­cÃ­m ÄÃ­slem?
df[df["ProductName"] == "Small Marshmallows Pink Bowl"]

# MÃ¡ produkt vÅ¯bec nÄ›kde produktovÃ© ÄÃ­slo, kterÃ© by se dalo pÅ™iÅ™adit?
df[(df["ProductName"] == "Small Marshmallows Pink Bowl") & (df["ProductNo"].notna())]

# Bude potÅ™eba produktÅ¯m pÅ™iÅ™adit jejich vlastnÃ­ produktovÃ¡ ÄÃ­sla. JAkÃ¡ je aktuÃ¡lnÃ­ obsazenost ÄÃ­sel?
# Najdeme minimum a maximum pouze mezi platnÃ½mi produktovÃ½mi ÄÃ­sly (bez NaN)
min_product_no = df["ProductNo"].min()
max_product_no = df["ProductNo"].max()

print(f"NejmenÅ¡Ã­ produktovÃ© ÄÃ­slo: {min_product_no}")
print(f"NejvÄ›tÅ¡Ã­ produktovÃ© ÄÃ­slo: {max_product_no}")

# VyfiltrovÃ¡nÃ­ unikÃ¡tnÃ­ch nÃ¡zvÅ¯ produktÅ¯, kde chybÃ­ ProductNo
unique_missing_products = df[df["ProductNo"].isna()]["ProductName"].unique()

# VÃ½pis vÃ½sledku
print(f"PoÄet unikÃ¡tnÃ­ch produktÅ¯ bez ProductNo: {len(unique_missing_products)}")
# print(unique_missing_products)

# Najdeme unikÃ¡tnÃ­ nÃ¡zvy produktÅ¯ bez ProductNo
missing_product_numbers = df[df["ProductNo"].isna()]["ProductName"].unique()

# VytvoÅ™Ã­me ÄÃ­selnou Å™adu pro novÃ© ProductNo, zaÄÃ­najÃ­cÃ­ od 1 000 001
new_numbers = {name: num for name, num in zip(missing_product_numbers, range(1000001, 1000001 + len(missing_product_numbers)))}

# PÅ™iÅ™adÃ­me novÃ© ÄÃ­slo vÅ¡em produktÅ¯m se stejnÃ½m nÃ¡zvem
df.loc[df["ProductNo"].isna(), "ProductNo"] = df["ProductName"].map(new_numbers)

# PÅ™evod na celÃ© ÄÃ­slo
df["ProductNo"] = df["ProductNo"].astype("Int64")

# VÃ½sledek - ukÃ¡zka prvnÃ­ch Å™Ã¡dkÅ¯
df[df["ProductNo"] >= 1000001].head()

# ProduktovÃ© ÄÃ­slo - kontrola nulovÃ½ch hodnot
df_missing_product = df[df["ProductNo"].isna()]
df_missing_product.head()

# ShrnutÃ­:
# ProduktovÃ¡ ÄÃ­sla komplet doplnÄ›na. VytvoÅ™ena produktovÃ¡ Å™eda od 1 000 001, pro 912 neoÄÃ­slovanÃ½ch typÅ¯ produktÅ¯.

# Kontrola nulovÃ½ch hodnot TransactionNo
df_missing_transaction = df[df["TransactionNo"].isna()]
df_missing_transaction.head()

# PoÄet zÃ¡znamÅ¯ se zÃ¡pornÃ½m mnoÅ¾stvÃ­m Quantity
negative_quantity_count = df[df["Quantity"] < 0].shape[0]
print(f"PoÄet poloÅ¾ek se zÃ¡pornÃ½m Quantity: {negative_quantity_count}")

# NÃ¡hled prvnÃ­ch 10 Å™Ã¡dkÅ¯ se zÃ¡pornÃ½m Quantity
negative_quantity_rows = df[df["Quantity"] < 0].head(10)
print(negative_quantity_rows)

# PoÄet chybÄ›jÃ­cÃ­ch TransactionNO a zÃ¡pornÃ½ch Quantity je stejnÃ½ - 8585
# VytvoÅ™Ã­m sloupec, kterÃ½ identifikuje vrÃ¡cenÃ© objednÃ¡vky, pÅ™idÃ¡nÃ­m novÃ©ho sloupce true/false

df["ReturnFlag"] = df["Quantity"] < 0
# df.head()
df["ReturnFlag"].value_counts()

df.head()

# NulovÃ© hodnoty po ÃºpravÄ›:

#  TransactionNo mÃ¡ 8 585 chybÄ›jÃ­cÃ­ch hodnot â†’ ponechÃ¡no beze zmÄ›ny, stejnÃ½ poÄet jako Quantity-
#  Quantity mÃ¡ 8585 zÃ¡pornÃ½ch hodnot - pÅ™ipojen sloupec ReturnFlag True/False
#  ProductNo mÃ¡ 50 921 chybÄ›jÃ­cÃ­ch hodnot â†’ chybÄ›jÃ­cÃ­ produktovÃ© ÄÃ­slo doplnÄ›no
#  CustomerNo mÃ¡ 55 chybÄ›jÃ­cÃ­ch hodnot â†’ chybÄ›jÃ­cÃ­ ID zÃ¡kaznÃ­ka

# kontrola nulovÃ½ch hodnot
df.isna().sum()

# Filtrujeme Å™Ã¡dky, kde CustomerNo je NaN a zÃ¡roveÅˆ ReturnFlag je True
missing_customers_with_returns = df[df["CustomerNo"].isna() & df["ReturnFlag"]]

# PoÄet tÄ›chto zÃ¡znamÅ¯
count_missing_customers_with_returns = missing_customers_with_returns.shape[0]

print(f"PoÄet zÃ¡znamÅ¯, kde chybÃ­ CustomerNo a zÃ¡roveÅˆ je ReturnFlag=True: {count_missing_customers_with_returns}")

# 54 zÃ¡znamÅ¯ s chybÄ›jÃ­cÃ­m CustomerNo a ReturnFlag=True:
  # MÅ¯Å¾e se jednat o anonymnÃ­ vrÃ¡cenÃ­ zboÅ¾Ã­, napÅ™Ã­klad v kamennÃ© prodejnÄ› bez potÅ™eby evidovat zÃ¡kaznÃ­ka.
  # Mohlo by to bÃ½t takÃ© Å¡patnÄ› zanesenÃ© v systÃ©mu.

# 1 zÃ¡znam s chybÄ›jÃ­cÃ­m CustomerNo, ale ReturnFlag=False:
  # To je divnÃ© â€“ znamenÃ¡ to, Å¾e nÄ›kdo nÄ›co koupil, ale nevÃ­me kdo.
  # MÅ¯Å¾e to bÃ½t chyba v datech, nebo Å¡lo o internÃ­ transakci.

# VÃ­ce neÅ¾ 8500 vrÃ¡cenÃ½ch objednÃ¡vek, kde je ÄÃ­slo zÃ¡kaznÃ­ka uvedeno:
  # ZÃ¡kaznÃ­k zboÅ¾Ã­ vrÃ¡til a bylo to spojeno s jeho ÃºÄtem.
  # To je v souladu s bÄ›Å¾nÃ½m procesem e-shopÅ¯, kde jsou vrÃ¡cenÃ© objednÃ¡vky spÃ¡rovÃ¡ny se zÃ¡kaznÃ­kem.

# 1 zÃ¡znam s chybÄ›jÃ­cÃ­m CustomerNo, ale ReturnFlag=False:

missing_customer_no_return_false = df[df["CustomerNo"].isna() & (df["ReturnFlag"] == False)]
print(missing_customer_no_return_false)

# ExistujÃ­ dalÅ¡Ã­ stejnÃ© TransactionNo 558245?

same_transaction = df[df["TransactionNo"] == "558245"]
print(same_transaction)

# PonechÃ¡m prÃ¡zdnÃ½, nelze spojit s Å¾Ã¡dnou jinou stransakcÃ­ pod uvedenÃ½m TransactionNo

# 54 zÃ¡znamÅ¯ s chybÄ›jÃ­cÃ­m CustomerNo a ReturnFlag=True:
# Chci najÃ­t, zda stejnÃ½ produkt a stejnÃ½ poÄet kusÅ¯ existoval v kladnÃ© hodnotÄ› (tedy jako nÃ¡kup) pÅ™ed datem vrÃ¡cenÃ­.
# Vybereme jednu vrÃ¡cenou poloÅ¾ku (nÄ›co s ReturnFlag=True).
# Najdu nejbliÅ¾Å¡Ã­ pÅ™edchozÃ­ zÃ¡znam, kde byl stejnÃ½ produkt koupen ve stejnÃ©m mnoÅ¾stvÃ­ (ale s kladnou hodnotou Quantity).
# Pokud se podaÅ™Ã­ najÃ­t, podÃ­vÃ¡m se, jestli odpovÃ­dÃ¡ CustomerNo (pokud je uvedeno).



# Vybereme jeden produkt, kterÃ½ byl vrÃ¡cen
test_product = df[df["Quantity"] < 0]["ProductNo"].iloc[0]

# SpoÄÃ­tÃ¡me celkovÃ½ poÄet prodanÃ½ch kusÅ¯ (Quantity > 0)
total_sold = df[(df["ProductNo"] == test_product) & (df["Quantity"] > 0)]["Quantity"].sum()

# SpoÄÃ­tÃ¡me celkovÃ½ poÄet vrÃ¡cenÃ½ch kusÅ¯ (Quantity < 0)
total_returned = abs(df[(df["ProductNo"] == test_product) & (df["Quantity"] < 0)]["Quantity"].sum())

print(f"Testujeme produkt ÄÃ­slo: {test_product}")
print(f"CelkovÃ½ prodej: {total_sold}")
print(f"CelkovÃ© vrÃ¡cenÃ­: {total_returned}")

# Najdeme zÃ¡znamy, kde byl produkt prodÃ¡n
sold_data = df[(df["ProductNo"] == test_product) & (df["Quantity"] > 0)]

# Najdeme zÃ¡znamy, kde byl produkt vrÃ¡cen
returned_data = df[(df["ProductNo"] == test_product) & (df["Quantity"] < 0)]

# SpojÃ­me data podle zÃ¡kaznÃ­ka
merged_data = sold_data.merge(returned_data, on="CustomerNo", suffixes=("_sold", "_returned"))

# ZobrazÃ­me prvnÃ­ch pÃ¡r vÃ½sledkÅ¯
print(merged_data[["CustomerNo", "TransactionNo_sold", "Quantity_sold", "TransactionNo_returned", "Quantity_returned"]].head(10))

# JAk to vypadÃ¡ u ostatnÃ­ch produktÅ¯? JednÃ¡ se o anomÃ¡lii, Å¾e chybÃ­ ÄÃ­slo transakce pÅ™i nÃ¡vratu?

# Najdeme produkty, kterÃ© byly kompletnÄ› vrÃ¡ceny
fully_returned_products = df.groupby("ProductNo")["Quantity"].sum()
fully_returned_products = fully_returned_products[fully_returned_products == 0]

# ZobrazÃ­me prvnÃ­ch pÃ¡r vÃ½sledkÅ¯
print(f"PoÄet produktÅ¯, kterÃ© byly kompletnÄ› vrÃ¡ceny: {len(fully_returned_products)}")
print(fully_returned_products.head(10))

# Filtrujeme jen tyto produkty
returned_products_df = df[df["ProductNo"].isin(fully_returned_products.index)]

# ZobrazÃ­me prvnÃ­ch pÃ¡r Å™Ã¡dkÅ¯
print(returned_products_df.head(10))

# Paper Craft Little Birdie (23843)
# JasnÃ© spojenÃ­: Pouze jeden zÃ¡kaznÃ­k (16446), kterÃ½ produkt koupil a vrÃ¡til ve stejnÃ½ den.

df.loc[(df["ProductNo"] == 23843) & (df["CustomerNo"].isna()), "CustomerNo"] = 16446

# Hanging Ridge Glass T-Light Holder (21655)
# ZÃ¡kaznÃ­k: 13672 â€“ koupil 24 ks a vrÃ¡til 2x po 12 ks.

df.loc[(df["ProductNo"] == 21655) & (df["CustomerNo"].isna()), "CustomerNo"] = 13672

# Black Cherry Lights (1000858)
# Dva zÃ¡kaznÃ­ci:
# ZÃ¡kaznÃ­k 13672 koupil 8 ks, vrÃ¡til 4 ks.
# ZÃ¡kaznÃ­k 15823 koupil 4 ks, vrÃ¡til vÅ¡echny.

df.loc[(df["ProductNo"] == 1000858) & (df["Quantity"] == -4), "CustomerNo"] = 13672
df.loc[(df["ProductNo"] == 1000858) & (df["Quantity"] == -4), "CustomerNo"] = 15823

# White Beaded Garland String 20light (85047)
# ProdÃ¡ny 3 ks rÅ¯znÃ½m zÃ¡kaznÃ­kÅ¯m, vrÃ¡ceny 3 ks.
# ZÃ¡kaznÃ­k 16222 koupil 1 ks.
# ZÃ¡kaznÃ­k 15311 a 13319 koupili 2 ks.
# 1 vrÃ¡cenÃ½ ks â†’ CustomerNo = 16222
# 2 vrÃ¡cenÃ© ks â†’ CustomerNo = 13319

df.loc[(df["ProductNo"] == 85047) & (df["Quantity"] == -1), "CustomerNo"] = 16222
df.loc[(df["ProductNo"] == 85047) & (df["Quantity"] == -2), "CustomerNo"] = 13319

# Glass Cake Cover And Plate (21667)
# Pouze jeden zÃ¡kaznÃ­k (17841) koupil a vrÃ¡til stejnÃ½ poÄet.

df.loc[(df["ProductNo"] == 21667) & (df["CustomerNo"].isna()), "CustomerNo"] = 17841

# Kde jeÅ¡tÄ› chybÃ­ CustomerNo?

missing_customers = df[df["CustomerNo"].isna()]
print("PoÄet zbÃ½vajÃ­cÃ­ch zÃ¡znamÅ¯ bez CustomerNo:", len(missing_customers))
display(missing_customers)

# 1 zÃ¡znam - chybÃ­ Quantity a CustomerNO, ale mÃ¡ TRansactionNo - ??

# Najdeme vÅ¡echny zÃ¡znamy se stejnÃ½m TransactionNo jako "Plasters In Tin"
related_transactions = df[df["TransactionNo"] == 563662]

# ZobrazÃ­me vÃ½sledek
display(related_transactions)

# Najdeme Å™Ã¡dek, kde chybÃ­ CustomerNo u "Plasters In Tin"
df.loc[
    (df["TransactionNo"] == 563662) & (df["ProductNo"] == 22554),
    ["CustomerNo", "Price", "Quantity"]
] = [12729, 11.94, 12]

# Zkontrolujeme opravenÃ½ Å™Ã¡dek
display(df[df["TransactionNo"] == 563662])

# ğŸ“Œ ShrnutÃ­ Ãºprav dat:
# âœ… TransactionNo â€“ Opraveno u chybÄ›jÃ­cÃ­ch zÃ¡znamÅ¯ na zÃ¡kladÄ› data a ÄÃ­sla zÃ¡kaznÃ­ka.
# âœ… ProductNo â€“ ChybÄ›jÃ­cÃ­ produktovÃ¡ ÄÃ­sla doplnÄ›na podle nÃ¡zvu produktu.
# âœ… Quantity â€“ PÅ™idÃ¡n novÃ½ sloupec ReturnFlag, aby bylo jasnÃ©, Å¾e zÃ¡pornÃ© hodnoty znamenajÃ­ vrÃ¡cenÃ­ zboÅ¾Ã­.
# âœ… CustomerNo â€“ 9 nevyplnÄ›nÃ½ch hodnot ponechÃ¡no prÃ¡zdnÃ½ch, protoÅ¾e chybÃ­ moÅ¾nost je dohledat.

df.to_csv("cleaned_sales_data.csv", index=False, encoding="utf-8")



